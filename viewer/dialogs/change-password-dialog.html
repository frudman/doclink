<!doctype component>

<!-- ALWAYS assumes <meta charset="UTF-8"> -->

<meta uses fancy-bit=https://doctype-component.io/@community/fancy-bit.html>
<meta uses plain-bits=https://community.doctype-component.io/plain-bits.html>
<meta uses on-demand live-bits=@community/rich-bits.html>
<meta uses preload live-bits=@community/rich-bits.html>

<!-- all requests in code are awaitable: const fancyBits = await meta.fancyBits; // in code -->

<meta fancy3='why not???'>
<meta name=var-name content='some text content'>

<meta fyi icon='data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAZ...'>
<meta fyi screenshot='https://...' on-demand>
<meta fyi screenshot='@/component/location/path' note='where @ is self-reference: same as source account, e.g. @community/ or @user-id/'>
<meta fyi screenshot='resource/asset here...'>

<!-- using self-ref of @ converts to inclusion in file whenever getting from GLOBAL REPOSITORY -->
<!-- EXCEPT MAYBE FOR extraneous details (e.g. screen shots) 
    how to indicate that bit is NOT important (e.g. screen shot) 
    on-demand attribute? if-used when-needed optional lazy-load lazy delay fyi 

    runtime 

    OR just parse file for meta when generating global directory

-->

<!-- on which platfrom can this run or not (below based on browser compatibility on developer.mozilla.org) -->
<meta supports ie.11=no chrome.64+ chrome.android firefox.17+ firefox.android edge.15+ edge.mobile opera opera.android safari safari.ios >
<meta supports chrome="64+ android" firefox.17+ firefox.android edge.15+ edge.mobile opera opera.android safari safari.ios >
<meta supports android-webview samsung-internet >
<meta supports node >
<meta supports ie.11+ chrome.latest-3 >

<meta title='...elements are tags used in HTML and XHTML documents to provide structured metadata about a Web page...'>
<meta title.fr-ca='...elements are tags used in HTML and XHTML documents to provide structured metadata about a Web page...'>
<meta author='Frederic Rudman'>
<meta summary='A portable component file format'>
<meta-notes lang=en-us>
    It's recommended to put all meta info at top of file. BUT it's ok to put some at bottom for reference (to start code view faster)
</meta-notes>
<meta-copyright>
    long established fact that a reader will be distracted by the readable content of a page when looking at its layout.
    The point of using Lorem Ipsum is that it has a more-or-less normal distribution of letters, as opposed to using 'Content here, 
    content here', making it look like readable English. Many desktop publishing packages and web page editors now use Lorem Ipsum as 
    their default model text, and a search for 'lorem ipsum
</meta-copyright>

<meta-description>
    any tag that starts with &lt;meta is treated as an information field and becomes an accesible variable<br>
    <b>for publishing</b> <u>should have</u>: copyrights or license, title, prefered component name, summary, author, description, how to use<br>
    BUT should only use these IF content is larger than a simple string (i.e. multiline)
</meta-description>

<!-- not sure what's the difference between uses and requires: if can't load a require, fails; if can't load a uses, warning? 
        maybe <meta uses optional ...> or <meta uses if-available ...>
        OR always warning UNLESS <meta uses required ...>
-->

<!-- IMPORTANT: 
    from section 2.2.3 [https://www.w3.org/TR/html5/infrastructure.html#conformance-requirements-extensibility] 
        (in 2nd to last paragraph ABOVE start of 2.2.4 (which is unrelated): 
            https://www.w3.org/TR/html5/infrastructure.html#interactions-with-xpath-and-xslt)

"User agents must treat elements and attributes that they do not understand as semantically neutral; 
leaving them in the DOM (for DOM processors), and styling them according to CSS (for CSS processors), 
but not inferring any meaning from them. -->

<meta requires plugin-api=simple jquery namx=@public/component >

<meta>

<meta requires subcomponents='comp1 comp2 ...' note='flagged as dependencies' >
<meta requires subcomponents> <!-- to load ANY subcomponent: flagged as OPEN -->

<meta name=var-name content='name or id?'>
<meta name=var-name src='href://download'>
<meta var-name5='but only if single attribute; dash-names converted to dashNames'>

<meta name=var-name src='https://domain.com/path/url/here.js'>
<meta name=var-name href='https://domain.com/path/url/here.js'>

<meta var-name2.src.json='https://domain.com/path/url/here.js'>

<meta vaName1="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAZAAAADSCAMAAABThmYtAAAAXVB">


<!-- IMPORTANT: do NOT shorcircuit tag names: e.g. <div .../> is INVALID
                MUST close properly: <div ...></div> -->



<main-part>
    <!-- a comment here -->
    <div $if=showing-dialog document-security-dialog>
        <h1>change locking password</h1>
        <input type=password placeholder='current {{password}} to be changed' :current @next>
        <input placeholder='new {{password}}' :new1 @next>
        <input placeholder='new {{password}} again' :new2 @next>
        <input placeholder='hint in case your forget' :hint @next=changePassword>
        <div><button ok @click.prevent.stopp=changePassword>change</button><button cancel @click=closeDialog>cancel</button></div>
    </div>
    <!-- a comment there -->
    <span $if=showing-dialog>just a note for help here</span><!-- a comment here also --><span>hello</span>
    <!-- a comment everywhere -->
    <ul $if=items.length>
        <li $for="item in items" $html="- {{item.text}}">
    </ul>
    <live-bits $if=hasBitsToEdit />
    <div $for="(item,i) in items" $html="dv-{{i}} {{item.text}}" :style :class :styling></div>
</main-part>

<div id=123>hellow?</div>

<style lang=less>

    /* https://stackoverflow.com/q/11353296/11256689 (less stylus scaa on the fly)
        browser support for less: http://lesscss.org/usage/
            - not great, not meant for production, still...

        of, could have a public service to do it for a component (e.g. while in dev mode?)

        maybe when updload to service, auto-scan/compile type=less, type=stylus, type=scss?
        BUT, how to parse tags in NODE??? (DOMParser NOT available, right?)

    */

    /* comp-css=... also a way to scope it */

    body,html, h1 > a, p + span:hover div[type~='something here?'],
    span:hover div[type~='nada']::after-burner ,
    
    body {
        color: white;
    }

    div[document-security-dialog] {
        display: flex;
        flex-direction: column;
        min-width: 350px;

        content: 'dfgsdfgsdfgsdfgsdfg\'sdfgsdfgsdfgs';

        background: red url("dfgsdfg\\\\\"sdfgsdfg\\\\''''''sdfgsdfg'{}]]]]]}}}}/* qqq ///");
        background: red url('dfgsdfgsdfgsdfg\'\'\\\'"""sdfgsdfg""{}]]]]]}}}}/* qqq ///');

        h1 {
            background: blue;
        }

        h1 {
            margin: 0;
            text-align: center;
            font: 600 28px system-ui;
        }

        div {
            display: flex;
            flex-direction: row;
        }

        h2 {
            font-size: 1em;
            text-align: center;
        }

        button {
            background: blue;
            padding: 5px;
            font-size: 1.1em;
            border-radius: 10px;
            flex: 1; /* spreads out */
            margin-right: 3px;
        }

        input {
            outline: none;
            padding: 3px;
            font-size: 1.1em;
            margin-bottom: 7px;
        }
    }
</style>

<style type=smart>

    @media(somethin) and (another=123) {
        [roofy] {
            color: port;

            & [some-elm] {
                color: tred;
            }
        }
    }

    @supports (browsers) {
        [elemntary] {
            color: black;
        }
    }


    /* https://stackoverflow.com/q/11353296/11256689 (less stylus scaa on the fly)
        browser support for less: http://lesscss.org/usage/
            - not great, not meant for production, still...

        of, could have a public service to do it for a component (e.g. while in dev mode?)

        maybe when updload to service, auto-scan/compile type=less, type=stylus, type=scss?
        BUT, how to parse tags in NODE??? (DOMParser NOT available, right?)

        default scope is local? can set comp-css.global='.5.4.'

    */

    /* comp-css=..3. also a way to scope it */

    :root {
        --main-bg-color: coral;
        --something-else: 120px;
    }

    ::local-scoped div {
        color: red;
    }

    comp-css {
        display: flex;
        flex-direction: column;
        min-width: 350px;
        color: var(--main-bg-color);
        background: --something-else; /* will be converted to var(--something-else); */
    }

    --cqa h1 {
        color: red;
    }

    :cqa h1 {
        color: red;
    }

    ::cqa h1 {
        color: red;
    }
    -css- h1 {
        color: red;
    }

    comp-css h1 {
        margin: 0;
        text-align: center;
        font: 600 28px system-ui;
    }

    comp-css div {
        display: flex;
        flex-direction: row;
    }

    comp-css h2 {
        font-size: 1em;
        text-align: center;
    }

    comp-css button {
        background: blue;
        padding: 5px;
        font-size: 1.1em;
        border-radius: 10px;
        flex: 1; /* spreads out */
        margin-right: 3px;
    }

    comp-css input {
        outline: none;
        padding: 3px;
        font-size: 1.1em;
        margin-bottom: 7px;
    }
</style>

<script note='should not read this' note-z='just comments and stuff'>
    console.log('hello? from very top?');
    /*
        idea is to move the display logic away from the html into a javascript object model
        - rather than think in terms of html, think in terms of javascript values
    */

    // todo: dynamic components: how to do this?
    // - create in html: <component ...>?
    // - create in code (just comp.new(...)?)


    /*
        file format is this:
        - ALWAYS STARTS with <!doctype component> (case INsensitive)
            - nothing else, no version, no name space, nothing
            - FIRST in the file (can be preceded with space characters but WHY DO IT???)
            - file extension is RECOMMENDED to be .html
                - maybe also .comp.html
                - but can actually be anything since loaded explicitly
        - 5 TOP-LEVEL TAGS:
            1- <!-- comments: which will be all & completely ignored until comment-closing tag -->
                - add plenty or none: completely ignored & skipped
            2- <meta>
                - add as many as you need (or none);
                - order is not important
                - all have 1 attrib: name, then src or value
                - OR <meta supports ie.11=no ...
                -    <meta requires 
                -    <meta version=1.5.4>
            --------------------------------------------------------------------------------
            3- <style>
                - add as many as you need (or none);
                - order matters ONLY for those WITHOUT IDs
            4- <script>
                - add as many as you need (or none);
                - order matters ONLY for those WITHOUT IDs
            5- <all-other-tags>
                - add as many as you need (or none);
                - order matters ONLY for those WITHOUT IDs
                - ONLY attribute on a TOP-LEVEL tag is ID
                    - top-level tag acts as a container/delimiter of the underlying/actual
                      html for that fragment/component/...
                    - top-level tag is NOT INCLUDED in rendered html
                        - rendered html can consist of 0 or more nodes/tags
                            - it is NOT required to be a single rooted tag (as per Vue, for example)
                    - ID is to distinguish it from all others
                    - must be explicitly "requested" (i.e. loaded) by code to be parsed/used
                        - unless part of default (all those without IDs are concatenated to each
                          other, in document order)
                        - and even the DEFAULT must be loaded or explicitly returned to be used

        - ALL tags of same type (style, script, other) without IDs are combined together in order
          in file (even if separated from others with other in-between tags)
        - ALL tags with IDs are kept as individuals and refered (in javascript (or html?) with that ID)
                - e.g. html.ID or script.ID or style.ID
                - in html, to include another part: <component html.ID ...attributes> (<include ...>?)

        - ALL Tags have attributes:
            - :name[=...] is a TWO-WAY bind with prop in data model                
            - @name[=...] is an EVENT Listener (onName...)
                - name can be custom (e.g. @next or @hello) or builtin (e.g. @click or @mouseover)
            - $directive[=...]
                - can be builtin or custom
                - builtin:
                    $if
                    $for                    
    */

    /*  - angular: never got the hang of it, not in its first iteration, not in its current form. my little brain explodes every time 
                   I try to give it a shot ("today, I WILL learn Angular...")
        - React: great for MANY MANY projects, MANY MANY people & companies
            - but already full expertise from so many folks for so many apps, I can bring nothing to the table
            - and, it's SERIOULSY HEAVY framework (not in a bad way) but you must be all in to use it
        - VUE: LOVE IT LOVE IT LOVE IT
            - it was the inspiration for dollar-if
            - GREAT to use
            - Easy(-ish) to learn
            - Powerful (not too heavy from codebase)
            - HOWEVER (but?)
                - does MANY MANY MANY things I don't need (and perhaps you don't need either)
                    - but still need to know about to make the most of it (and not create bugs)
                - does NOT do a few things (just a few) that I REALLY WANT/NEED (more on this below)
                - i disagreed with some of Vue's philosophies (again, not in a bad way, just different opinions on this or that)
            - So...
            - I created dollar-if to address these issues
                1- wanted something very lightweight from a learning perspective
                2- wanted something that made easy work for easy needs
                3- wanted something that made html code clean
                4- wanted something that made javascript simple
                5- wanted a framework that was dead simple to learn with few rules to learn and few (or no) exceptions
                   to memorize in order to use (& make the most of)
                6- wanted a file format that could immediately leverage intellisence tools of today 
                    - e.g. css props, html tags, javascript...
                    - hence the recommended .html extension
                7- wanted a file format that average developers (like you? ðŸ˜ƒ) with minimal html/css/javascript background
                   could look at and understand AND be able to make at least minor tweaks to WIHTOUT needing
                   to "learn" dollar-if

        MUST READ: https://gomakethings.com/why-i-wrote-my-own-vanilla-js-alternative-to-vue-and-react/

        - a simple **contained** file makes it easier to move components back and forth for others to use
            - has ALL the elements required for today's UI (html, css/style, code/javascript)
                - assets can be referenced from same source as component:
                    - if component is at https://domain.com/some/path/here/component-name.html
                        - all assets as: https://domain.com/some/path/here/component-name.html/asset1-name.jpg
        - NO BUILD means source is always visible...
            - [for you & others] to tweak
            - [for you & others] to check for bugs
            - [for you & others] to check for malicious code
        - NO BUILD means its directly usable in a browser app, AS-IS
            - (e.g. for plugin-based apps)
        
    */

    /* Some of my philosophies
        - most focused on LEGIBILITY of code
            - easier to create & maintain after the facts (e.g. months/years later)
            - easier to debug when simpler, cleaner code/html
            - minimize (or eliminate) repetitive text/characters (e.g. " or v- or ...)
        - less concerned about optimizations
            - MOST IMPORTANT ONE for those coming from Vue/React/Angular
            - expect to work really well and fast on smaller components or smaller data models
              (e.g. an array with less than, say, 1000 records)
            - will need to test for your use cases if working on large datasets (e.g. > 10,000 records
              where you modify many rows/record very in short order (e.g. < a few milliseconds))
            - best for basic/typical app UI
            - likely not best for extensive apps (e.g. games, audio/video/image editors, databse record dashbords)
              where microsecond redraws are important, or on memory constrained devices
        - most concerned about quickly learning the basics...
            - then let you realize there's nothing more to learn (wysiwyg)
        - clean separation of code & html 
        - but close prozimity of these for easier long-term maintenance (namely, in the same file)
        - very concerned about component PORTABILITY and REUSABILITY
            - by you (for your own app)
            - by others
        - clear visual distinction in html between "standard stuff" (e.g. <div>) and framework stuff (e.g. $if)
        - some flexibility in choices:
            - NOT RECOMMENDED but CAN change $-prefix to something else (e.g. v- or hello-)
                so: <div v-if=...> or <div hello-if=...>
    */
</script>
        
       
<script note='this is main code'>
    const {html, style, meta, script, api: { load, live, log }, } = this; // this is STATIC parts of this component

    // so this.x makes X a static property of component

    // what about this.script.idHere: to use as module? to run? 

    const helperApi = script.helpers;

    const staticData = {

    }

    const inpFld = () => ({value:'', tooltip: '', focus: ''}); // for convenience

    function newInstance() {

    }

    // done once (but could do on every instantiation)
    // req: changes to object structure frozen once in use?
    var _tmpx;
    function randomFcn(...args){
        log('***** exec randomFcn', args);
    };
    randomFcn.propx = 123;
    randomFcn.propxyx = "123abc";
    randomFcn.propicious = (...args) => x = args;

    const subPx = {
        anotherSub: 'property',
        andYet: 'another as well',
        lastly: 123,
    }

    const ctrl = live({ // or data({}) OR MODEL({})
        current: inpFld(),
        new1: inpFld(), 
        new2: inpFld(),
        hint: inpFld(),

        showingDialog: false,
        async changePassword(){}, // set each time from caller (a function)
        closeDialog(){ ctrl.showingDialog = false;},

        randomFcn,
        xyz: randomFcn, // so an alias for randomFcn: is this a problem listeting to events?

        subPx,

        password: 'password or passphrase',

        arrx: [1,2,'abc'],

        // testing getter/setters
        get prop1() { log('prop1 from a getter', _tmpx); return _tmpx; },
        set prop2(val) { _tmpx = val; log('prop1 SETTER to', _tmpx); return true; },

        get prop2GetOnly() { log('prop1 from a getter', _tmpx); return _tmpx; },
    });

    log('OK, testing');
    ctrl.password = 'using passphrase';

    ctrl.arrx[5] = 123;
    ctrl.arrx[1000] = "lastly?";
    log('well???', ctrl.arrx.length);
    ctrl.arrx.push(...'a b c d e'.split(' '))
    ctrl.arrx.pop();
    ctrl.arrx.shift();
    ctrl.arrx = ['another', 'array', 678];

    log('nowq', ctrl.xyz.propx, ';', typeof ctrl.xyz.propx, ';', typeof ctrl.xyz, ctrl.xyz, ctrl.xyz('1','ww', 3));
    ctrl.xyz.propx = "xyz IS THIS CAUGHT??? NO I don't think so";
    ctrl.xyz('some', 'parms', 123);

    ctrl.subPx.lastly = 76;

    ctrl.subPx = {
        qq33: 123,
        qq33HELLO: 'string here',
        qqSUBObj: { 
            pqa: 123
        }
    }

    ctrl.subPx.qqSUBObj.pqa = "winner!";


    // ctrl.new2 = { another: 'object' };
    // ctrl.hint.value = 123; // missed (sub object)


    // done once: BUT, could be done on EACH instantiation
    load.css(style.default);//, ctrl); // preprocessing done by load.css before inserting css-string to main doc; always inserted in doc.head
    load.html(html.mainPart);//, ctrl); // same as document.body.append(...); a THIRD parm to specify WHERE to add in main doc? a string selector?

    // maybe return the element itself (to be loaded wherever in document)?
    // then attach its .api to element itself?

    // IF NO RETURN method, then what???
    // SHOULD still be a valid component (right?)
    // - with just html
    // - so default html returned as an element?
    //      - but what is the 'default' part of element?
    
    return { // returned value for a component is its static API

        new() {
            // to actually create an instance of this component
            // which html to use, with which data model

            // if NO NEW method, then what?
        },

        // need a render method for embedding this component explicitly in another's html
        // - replace or enhance existing el?

        display(checkPwd) { // called by parent when need to show dialog: await comp.display(...);
            return ctrl.changePassword ? 'already using dialog' : // can only show once
                new Promise(resolve => {
                    ctrl.changePassword = async pwd => {
                        const res = await checkPwd(pwd);
                        if (typeof res === 'string') {
                            ctrl.current.value = ctrl.new1.value = ctrl.new2.value = ''; // clear all for inconvenience
                            ctrl.current.tooltip = `invalid current password` + (res ? ` (hint: ${res})`:``);
                        }
                        else if (ctrl.new1.value.length === 0) 
                            ctrl.new1.tooltip = 'need new password';
                        else if (ctrl.new1.value !== ctrl.new2.value)
                            ctrl.new1.tooltip = { // modifier? modifiers: ['brief', '2.5s']
                                value: 'need new password',
                                attr: 'brief.2.5s' // equivalent to tooltip.brief.2.5s='need new password'
                            };
                        else {
                            ctrl.showingDialog = false; // effectively closes dialog
                            resolve({password: ctrl.new1, hint: ctrl.hint});
                        }
                    };
                    ctrl.showingDialog = true;
                    ctrl.current.focus = true;
                });
        },
    }
</script>

<script id=for-notes-only other-attr last-attr=123>

    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/isFrozen
    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/isSealed


    // called as function(doctypeComponent, window, document) {...}
    // - doctypeComponent deliberately long so as to not be used directly (too opiniated?)
    // - window & document are blank for simple error check (cannot actually prevent one from access to them)
    // - can use await & async (parent function is async)
    // - "this" represents THIS INSTANCE (right?)

    // <!-- object passed has props as per below (e.g. .password) -->
    // <!-- all {{expressions}} converted to live code -->
    // <!-- if {{expression}} contains prop name, add listener on each .set -->


    // how to know that this is a NEW INSTANCE execution, the 2nd-n time around?
    // pass a parm showing previous instances?

    // or maybe if I load it again, it should be a different/separate instance?

    // how to create/access static component data?
    // MAYBE, pass a static object to each component to use as they please?
    // - live static? staticComponentData?

    // how/when to convert ctrl to proxy & attach to html/css?
    // AHHHHH: do it when calling load.fcn(..., ctrl);

        // load.script()? 
    // if allows for document or window, caller can pass to component api
</script>

<templ id=test-1 $uses="toolbox, another, parmHere">
    toolbox tools: 
        (really should be in a header tag or something)
    <ul $if="toolbox.numEntries > 0">
        <li $for="tool in toolbox" $text="{{tool.type + ': ' + tool.name}}" @click=tool.action>
    </ul>
    <div $elseif=toolbox>no tools added to toolbox</div>
    <div $else>toolbox feature not available</div>
    <button $for="tool in toolbox" @click=tool.action>tool: {{tool.name}}</button>
</templ>

<script id=not-main>
    // main api
    // QUESTION: allow $if on tld elements? e.g. <main-part $if=...>
    // BUT, tags are not loaded anywhere yet (just fragments)
    // SO, $if becomes meaningless; $if only makes sense once loaded into main doc

    // need an ATTRIBUTE listener (document wide)
    // ANY element can use special attributes (e.g. tooltip) that when set, something happens

    // $=# to change prefix; $=v- $=...

    // vulite; vuelite; viewLite; veeulite; voulez-vous

    // 4 changes from html:
    // - $directives (builtins: $if $for)
    // - @event-handlers (@click @next)
    // - :live-attributes
    // - {{text expressions}}

    // special consideration for: style, class, input.value/textarea

    // 2 big tasks:
    // 1- proxying model-controller object
    //  1b- then add listeners to each prop
    // 2- parsing/processing $instructions

    mainApi.registerLiveAttribute('tooltip', el => {
        // el's tooltip attribute has been set/changed
        if (el.tooltip) {
            // display it
            // maybe even remove it afterwards? if tooltip.brief='...'
            // UNLESS tooltip.always='...'
        }
        else {
            // hide it
            fld.hint = h;
            setTimeout(() => fld.hint = '', 2500);
        }
    });

    mainApi.registerLiveAttribute('focus', el => {
        // el is an input to be focused on
    });

    mainApi.registerGlobalEvent('next', () => {
        // used in input forms to move to next input field (if any) on enter key
        // or, if used as '@next=action', to do action();
    });
</script>

<script id=not-main-also>

    // dollar code

    // returned object/function is component's api: the only means to access/control this component
    // - if return nothing, can't control component after instantiated (but can remove/change doc placement since just a dom element)

    // html.tag = el if single
    // html.tag = [el,...] if multiple
    // html.idCamel = single el for each with ID; preferred means of access
    // html.default = ???

    const {html, style, meta, api: { load, send, otherStuff}} = doctypeComponent; // api?

    const inpFld = () => ({value:'', tooltip: ''}); // for convenience

    // done once (but could do on every instantiation)
    const ctrl = {
        current: inpFld(),
        new1: inpFld(), 
        new2: inpFld(),
        hint: inpFld(),

        showingDialog: false,
        async changePassword(){}, // set each time from caller
        closeDialog(){ ctrl.showingDialog = false;},

        password: 'password or passphrase',
    }

    // done once: BUT, could be done on EACH instantiation
    load.css(style.default); // how to pre-process? load uniquely? or in main doc? HANDLED by load.css before inserting css-string to main doc
    load.html(html.mainPart, ctrl); // same as document.body.append(...); a THIRD parm to specify WHERE to add in main doc?

    // returned value for a component is its API
    return {
        display(checkPwd) { // called by parent when need to show dialog: await comp.display(...);
            return ctrl.changePassword ? 'already using dialog' : // can only show once
                new Promise(resolve => {
                    ctrl.changePassword = async pwd => {
                        const res = await checkPwd(pwd);
                        if (typeof res === 'string') {
                            ctrl.current.value = ctrl.new1.value = ctrl.new2.value = ''; // clear all for inconvenience
                            ctrl.current.tooltip = `invalid current password` + (ok ? ` (hint: ${ok})`:``);
                        }
                        else if (ctrl.new1.value.length === 0) 
                            ctrl.new1.tooltip = 'need new password';
                        else if (ctrl.new1.value !== ctrl.new2.value)
                            ctrl.new1.tooltip = {
                                value: 'need new password',
                                attr: 'brief.5s' // equivalent to tooltip.brief.5s='need new password'
                            };
                        else {
                            ctrl.showingDialog = false;
                            resolve({password: ctrl.new1, hint: ctrl.hint});
                        }
                    };
                    ctrl.showingDialog = true;
                    //pwdInp.focus(); // HOW TO DO THIS???
                });
        },
    }
</script>

<div id=maybe>hellow?</div>


<!-- order of metas is immaterial -->
<meta name=`some-name` content='anything you wish: becomes module-global variable someName - assumes content is TEXT'>
<meta name=some-name content.json='{json:"goes here"}'>
<meta name=some-name content.audio='base64:...'>
<meta name=some-name content.audio.base64='...'>
<meta name=another-title2 src='http://domain.com/url' note="this assumes it's a component">
<meta name=another-title3 src.json='http://domain.com/url'>
<meta name=another-title3 src.text='http://domain.com/url'>

<!-- make an array of those below since same name? -->
<meta name=another-title src.audio='http://domain.com/url'>
<meta name=another-title src.video='http://domain.com/url'>
<meta name=another-title src.binary='http://domain.com/url'>
<meta name=another-title src.text='http://domain.com/url'>

<meta name=local-name-here component=https://domain.com/compenent-wanted.html>

<div id=final>hellow?</div>
